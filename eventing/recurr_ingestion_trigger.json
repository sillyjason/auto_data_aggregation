[{"appcode":"function CreateRecurringTimer(context) {\n    log('From CreateRecurringTimer: creating timer', context.mode, context.id);\n    // Create a timestamp 60 seconds from now\n    var sixtySecFromNow = new Date(); // Get current time & add 60 sec. to it.\n    sixtySecFromNow.setSeconds(sixtySecFromNow.getSeconds() + 60);\n    // Create a document to use as out for our context\n    createTimer(RecurringTimerCallback, sixtySecFromNow, context.id, context);\n}\n\nfunction generateUUID() {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n        const r = Math.random() * 16 | 0;\n        const v = c === 'x' ? r : (r & 0x3 | 0x8);\n        return v.toString(16);\n    });\n}\n\nfunction RecurringTimerCallback(context) {\n    log('From RecurringTimerCallback: timer fired', context);\n    // rearm the timer ASAP, to ensure timer keeps running in the event\n    // of later  errors or script timeouts in later \"recurring work\".\n    var count = context.count;\n    CreateRecurringTimer({ \"id\": context.id, \"mode\": \"via_callback\", \"count\": count });\n    // do any sort of recurring work here, just update a date_stamp in a doc\n    \n    // generate temp documents in a loop\n    for (let i = 0; i < count; i++) {\n        var uuid = generateUUID()\n        temp_collection[uuid] = {\"count\": count}\n    }\n}\n\nfunction OnUpdate(doc, meta) {\n    // You would typically filter to mutations of interest\n    if (doc.active === false) {\n        if (cancelTimer(RecurringTimerCallback, meta.id)) {\n            log('From OnUpdate: canceled active Timer, doc.active',\n                doc.active, meta.id);\n        } else {\n            log('From OnUpdate: no active Timer to cancel, doc.active',\n                doc.active, meta.id);\n        }\n    } else {\n        log('From OnUpdate: create/overwrite doc.active', doc.active, meta.id);\n        \n        // initiate the doc count for triggering data ingestion loop iterations \n        var count = 100 \n        if ( doc.count ) { \n            count = doc.count\n        }\n        \n        CreateRecurringTimer({  \"id\": meta.id, \"mode\": \"via_onupdate\", \"count\": count });\n    }\n}","depcfg":{"buckets":[{"alias":"temp_collection","bucket_name":"main","scope_name":"data","collection_name":"temp","access":"rw"}],"source_bucket":"eventing","source_scope":"_default","source_collection":"one_off_trigger_one","metadata_bucket":"eventing","metadata_scope":"_default","metadata_collection":"_default"},"version":"evt-7.6.1-3200-ee","enforce_schema":false,"handleruuid":3848168990,"function_instance_id":"ehh023","appname":"recurr_ingestion_trigger","settings":{"dcp_stream_boundary":"everything","deployment_status":false,"description":"","execution_timeout":60,"language_compatibility":"7.2.0","log_level":"INFO","n1ql_consistency":"none","num_timer_partitions":128,"processing_status":false,"timer_context_size":1024,"user_prefix":"eventing","worker_count":1},"function_scope":{"bucket":"*","scope":"*"}}]