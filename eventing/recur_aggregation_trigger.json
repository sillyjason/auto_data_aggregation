[{"appcode":"function CreateRecurringTimer(context) {\n    log('From CreateRecurringTimer: creating timer', context.mode, context.id);\n    \n    // Create timestamp for next minute \n    var nextMinute = new Date(); \n    const currentSeconds = nextMinute.getSeconds();\n\n    if (currentSeconds !== 0) {\n        nextMinute.setSeconds(0);\n        nextMinute.setMinutes(nextMinute.getMinutes() + 1);\n    }\n   \n    // Create a document to use as out for our context\n    createTimer(RecurringTimerCallback, nextMinute, context.id, context);\n}\n\n\nfunction RecurringTimerCallback(context) {\n    log('From RecurringTimerCallback: timer fired', context);\n    // rearm the timer ASAP, to ensure timer keeps running in the event\n    // of later  errors or script timeouts in later \"recurring work\".\n    CreateRecurringTimer({ \"id\": context.id, \"mode\": \"via_callback\" });\n    // do any sort of recurring work here, just update a date_stamp in a doc\n    \n    // run the aggregation query\n    var results = \n    with n as (trunc(now_millis()/1000))\n        ,o as (n%60)\n        ,e as (n-o)\n        ,s as (e-60)\n    SELECT\n        COUNT(1) AS count,\n        AVG(`amount`) AS average_amt,\n        SUM(`amount`) AS total_amt,\n        {\"silver\": SUM(CASE WHEN cust_type = \"silver\" THEN 1 ELSE 0 END) ,\n        \"gold\": SUM(CASE WHEN cust_type = \"gold\" THEN 1 ELSE 0 END),\n        \"platinum\": SUM(CASE WHEN cust_type = \"platinum\" THEN 1 ELSE 0 END)\n        } AS category,\n        MILLIS_TO_STR(e * 1000) as end_time_fmt,\n        MILLIS_TO_STR(s * 1000) as start_time_fmt,\n        MILLIS_TO_STR(n * 1000) as trigger_time_fmt,\n        e as end_time,\n        s as start_time,\n        n as trigger_time\n    FROM `main`.`data`.`data`\n    WHERE `time_unix` BETWEEN s AND e\n    GROUP BY e, s, n;\n    \n\n    for (var item of results) {   // Stream results using 'for' iterator.\n        minute_collection[item.start_time_fmt] = item\n    }\n    \n    results.close()\n    \n}\n\nfunction OnUpdate(doc, meta) {\n    // You would typically filter to mutations of interest\n    if (doc.active === false) {\n        if (cancelTimer(RecurringTimerCallback, meta.id)) {\n            log('From OnUpdate: canceled active Timer, doc.active',\n                doc.active, meta.id);\n        } else {\n            log('From OnUpdate: no active Timer to cancel, doc.active',\n                doc.active, meta.id);\n        }\n    } else {\n        log('From OnUpdate: create/overwrite doc.active', doc.active, meta.id);\n        CreateRecurringTimer({  \"id\": meta.id, \"mode\": \"via_onupdate\" });\n    }\n}","depcfg":{"buckets":[{"alias":"minute_collection","bucket_name":"main","scope_name":"aggregation","collection_name":"minute","access":"rw"}],"source_bucket":"eventing","source_scope":"_default","source_collection":"one_off_trigger_two","metadata_bucket":"eventing","metadata_scope":"_default","metadata_collection":"_default"},"version":"evt-7.6.1-3200-ee","enforce_schema":false,"handleruuid":912850380,"function_instance_id":"ZMpa42","appname":"recur_aggregation_trigger","settings":{"dcp_stream_boundary":"everything","deployment_status":false,"description":"","execution_timeout":60,"language_compatibility":"7.2.0","log_level":"INFO","n1ql_consistency":"request","num_timer_partitions":128,"processing_status":false,"timer_context_size":1024,"user_prefix":"eventing","worker_count":1},"function_scope":{"bucket":"*","scope":"*"}}]